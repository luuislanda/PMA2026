<template>
  <div class="typed-code-block-container">
    <pre class="shiki"><code ref="typedElement" :class="languageClass"></code></pre>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, computed, nextTick } from 'vue';
import { default as TypedJS } from 'typed.js';
import { createHighlighter } from 'shiki';
import { onSlideEnter, onSlideLeave } from '@slidev/client';

interface Props {
  code: string;
  language?: string;
  typeSpeed?: number;
  startDelay?: number;
  showCursor?: boolean;
  cursorChar?: string;
}

const props = withDefaults(defineProps<Props>(), {
  typeSpeed: 50,
  startDelay: 0,
  showCursor: true,
  cursorChar: '|',
});

const typedElement = ref<HTMLElement | null>(null);
let typedInstance: TypedJS | null = null;
let highlighter: any = null;
const hasTyped = ref(false);
let highlightedStrings: string[] = [];

const languageClass = computed(() => {
  return props.language ? `language-${props.language}` : '';
});

const decodeHtml = (html: string): string => {
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
};

const splitIntoLines = (code: string): string[] => {
  const lines = code.split('\n');
  const progressiveLines: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const currentLines = lines.slice(0, i + 1);
    progressiveLines.push(currentLines.join('\n'));
  }
  
  return progressiveLines;
};

const highlightCode = async (code: string) => {
  if (!highlighter || !props.language) {
    return code.replace(/\n/g, '<br>');
  }
  
  try {
    const highlighted = await highlighter.codeToHtml(code, {
      lang: props.language,
      theme: 'github-dark'
    });
    
    // Extract just the code content from the HTML
    const match = highlighted.match(/<code[^>]*>(.*?)<\/code>/s);
    return match ? match[1] : code.replace(/\n/g, '<br>');
  } catch (error) {
    console.warn('Failed to highlight code:', error);
    return code.replace(/\n/g, '<br>');
  }
};

const startTyping = async () => {
  if (!typedElement.value || typedInstance) return;

  const options = {
    strings: highlightedStrings,
    typeSpeed: props.typeSpeed,
    backSpeed: 0,
    backDelay: 0,
    startDelay: props.startDelay,
    loop: false,
    showCursor: props.showCursor,
    cursorChar: props.cursorChar,
    smartBackspace: true,
    contentType: 'html' as const,
  };

  typedInstance = new TypedJS(typedElement.value, options);
  hasTyped.value = true;
};

const resetTyping = () => {
  if (typedInstance) {
    typedInstance.destroy();
    typedInstance = null;
  }
  hasTyped.value = false;
  if (typedElement.value) {
    typedElement.value.innerHTML = '';
  }
};

// Set up Slidev hooks
console.log('TypedCodeBlock: Setting up Slidev hooks');

onSlideEnter(() => {
  console.log('TypedCodeBlock: Slide entered, starting typing');
  resetTyping();
  nextTick(() => {
    setTimeout(() => {
      if (highlightedStrings.length > 0) {
        startTyping();
      }
    }, 100);
  });
});

onSlideLeave(() => {
  console.log('TypedCodeBlock: Slide left, stopping typing');
  if (typedInstance) {
    typedInstance.stop();
  }
});

onMounted(async () => {
  if (!typedElement.value) return;

  // Initialize Shiki highlighter
  if (props.language) {
    try {
      highlighter = await createHighlighter({
        themes: ['github-dark'],
        langs: [props.language]
      });
    } catch (error) {
      console.warn('Failed to initialize highlighter:', error);
    }
  }

  // Decode HTML entities and split code into progressive lines
  const decodedCode = decodeHtml(props.code);
  const progressiveLines = splitIntoLines(decodedCode);
  
  // Highlight each progressive step and store globally
  highlightedStrings = await Promise.all(
    progressiveLines.map(code => highlightCode(code))
  );

  // The Slidev hooks will handle starting the animation when the slide is entered
});

onBeforeUnmount(() => {
  resetTyping();
});

defineExpose({
  start: () => typedInstance?.start(),
  stop: () => typedInstance?.stop(),
  reset: () => resetTyping(),
  restart: () => {
    resetTyping();
    nextTick(() => startTyping());
  },
});
</script>

<style scoped>
.typed-code-block-container {
  border-radius: 6px;
  overflow: auto;
  background: #0d1117;
  padding: 1rem;
  margin: 0.5rem 0;
}

.typed-code-block-container pre {
  margin: 0;
  background: transparent !important;
  padding: 0;
  overflow: visible;
  font-family: 'Fira Code', 'JetBrains Mono', 'SF Mono', Monaco, Consolas, monospace;
}

.typed-code-block-container code {
  background: transparent !important;
  padding: 0;
  font-family: inherit;
  font-size: 14px;
  line-height: 1.5;
  display: inline;
  white-space: pre;
  position: relative;
}

.typed-code-block-container :deep(.typed-cursor) {
  display: inline !important;
  vertical-align: baseline !important;
  line-height: inherit !important;
  font-size: inherit !important;
  height: 1em !important;
  color: #e6edf3 !important;
  background: transparent !important;
  animation: blink 1s infinite !important;
  position: static !important;
  float: none !important;
  clear: none !important;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.typed-code-block-container :deep(span) {
  white-space: pre;
}
</style>