<template>
  <div class="typed-code-container">
    <pre><code ref="typedElement" :class="languageClass"></code></pre>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, computed } from 'vue';
import { default as TypedJS } from 'typed.js';
import { createHighlighter } from 'shiki';

interface Props {
  code: string[];
  language?: string;
  typeSpeed?: number;
  backSpeed?: number;
  backDelay?: number;
  startDelay?: number;
  loop?: boolean;
  loopCount?: number;
  showCursor?: boolean;
  cursorChar?: string;
  smartBackspace?: boolean;
  shuffle?: boolean;
  onComplete?: () => void;
}

const props = withDefaults(defineProps<Props>(), {
  code: () => ['console.log("Hello World!");'],
  typeSpeed: 50,
  backSpeed: 30,
  backDelay: 1500,
  startDelay: 0,
  loop: false,
  loopCount: Infinity,
  showCursor: true,
  cursorChar: '|',
  smartBackspace: true,
  shuffle: false,
});

const typedElement = ref<HTMLElement | null>(null);
let typedInstance: TypedJS | null = null;
let highlighter: any = null;

const languageClass = computed(() => {
  return props.language ? `language-${props.language}` : '';
});

// Convert newlines to HTML breaks for proper rendering
const processedCode = computed(() => {
  return props.code.map(code => code.replace(/\\n/g, '\n'));
});

const highlightCode = async (code: string) => {
  if (!highlighter || !props.language) {
    return code.replace(/\n/g, '<br>');
  }
  
  try {
    const highlighted = await highlighter.codeToHtml(code, {
      lang: props.language,
      theme: 'github-dark'
    });
    
    // Extract just the code content from the HTML
    const match = highlighted.match(/<code[^>]*>(.*?)<\/code>/s);
    return match ? match[1] : code.replace(/\n/g, '<br>');
  } catch (error) {
    console.warn('Failed to highlight code:', error);
    return code.replace(/\n/g, '<br>');
  }
};

onMounted(async () => {
  if (!typedElement.value) return;

  // Initialize Shiki highlighter
  if (props.language) {
    try {
      highlighter = await createHighlighter({
        themes: ['github-dark'],
        langs: [props.language]
      });
    } catch (error) {
      console.warn('Failed to initialize highlighter:', error);
    }
  }

  // Pre-process code with syntax highlighting
  const highlightedStrings = await Promise.all(
    processedCode.value.map(code => highlightCode(code))
  );

  const options = {
    strings: highlightedStrings,
    typeSpeed: props.typeSpeed,
    backSpeed: props.backSpeed,
    backDelay: props.backDelay,
    startDelay: props.startDelay,
    loop: props.loop,
    loopCount: props.loopCount,
    showCursor: props.showCursor,
    cursorChar: props.cursorChar,
    smartBackspace: props.smartBackspace,
    shuffle: props.shuffle,
    contentType: 'html' as const,
    onComplete: (self: any) => {
      if (props.onComplete) {
        props.onComplete();
      }
    },
  };

  typedInstance = new TypedJS(typedElement.value, options);
});

onBeforeUnmount(() => {
  if (typedInstance) {
    typedInstance.destroy();
    typedInstance = null;
  }
});

defineExpose({
  start: () => typedInstance?.start(),
  stop: () => typedInstance?.stop(),
  toggle: () => typedInstance?.toggle(),
  reset: () => typedInstance?.reset(),
});
</script>

<style scoped>
.typed-code-container {
  border-radius: 6px;
  overflow: auto;
  background: #0d1117;
  padding: 1rem;
  margin: 0.5rem 0;
}

.typed-code-container pre {
  margin: 0;
  background: transparent !important;
  padding: 0;
  overflow: visible;
  font-family: 'Fira Code', 'JetBrains Mono', 'SF Mono', Monaco, Consolas, monospace;
}

.typed-code-container code {
  background: transparent !important;
  padding: 0;
  font-family: inherit;
  font-size: 14px;
  line-height: 1.5;
  display: inline;
  white-space: pre;
  position: relative;
}

/* Fix cursor positioning for code blocks */
.typed-code-container :deep(.typed-cursor) {
  display: inline !important;
  vertical-align: baseline !important;
  line-height: inherit !important;
  font-size: inherit !important;
  height: 1em !important;
  color: #e6edf3 !important;
  background: transparent !important;
  animation: blink 1s infinite !important;
  position: static !important;
  float: none !important;
  clear: none !important;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* Ensure Shiki styles are preserved */
.typed-code-container :deep(span) {
  white-space: pre;
}
</style>